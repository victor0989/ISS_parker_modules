library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity SPI_MASTER is
    generic (
        CLK_FREQ    : natural := 50000000; -- frecuencia reloj sistema (Hz)
        SCLK_FREQ   : natural := 5000000;  -- frecuencia reloj SPI (Hz), debe cumplir SCLK_FREQ <= CLK_FREQ/10
        WORD_SIZE   : natural := 8;         -- tamaño palabra bits (potencia de 2)
        SLAVE_COUNT : natural := 1          -- número de esclavos SPI
    );
    port (
        CLK      : in  std_logic; -- reloj sistema
        RST      : in  std_logic; -- reset síncrono activo alto
        -- Interfaz SPI master
        SCLK     : out std_logic; -- reloj SPI
        CS_N     : out std_logic_vector(SLAVE_COUNT-1 downto 0); -- chip select activo bajo
        MOSI     : out std_logic; -- datos master->slave
        MISO     : in  std_logic; -- datos slave->master
        -- Interfaz usuario
        DIN      : in  std_logic_vector(WORD_SIZE-1 downto 0); -- datos para transmitir
        DIN_ADDR : in  std_logic_vector(0 downto 0); -- dirección esclavo SPI (solo 1 esclavo aquí)
        DIN_LAST : in  std_logic;  -- último dato, desactiva CS_N tras enviar
        DIN_VLD  : in  std_logic;  -- datos válidos
        DIN_RDY  : out std_logic;  -- ready para aceptar datos
        DOUT     : out std_logic_vector(WORD_SIZE-1 downto 0); -- datos recibidos
        DOUT_VLD : out std_logic   -- datos recibidos válidos
    );
end SPI_MASTER;

architecture RTL of SPI_MASTER is

    -- Constantes calculadas a mano
    constant DIVIDER_VALUE : natural := CLK_FREQ / SCLK_FREQ / 2; -- para dividir el reloj
    constant WIDTH_CLK_CNT : natural := 13;  -- suficiente para contar hasta DIVIDER_VALUE (~2500)
    constant WIDTH_ADDR    : natural := 1;   -- para SLAVE_COUNT=1
    constant BIT_CNT_WIDTH : natural := 3;   -- para WORD_SIZE=8

    type state_t is (idle, first_edge, second_edge, transmit_end, transmit_gap);

    signal addr_reg        : unsigned(WIDTH_ADDR-1 downto 0) := (others => '0');
    signal sys_clk_cnt     : unsigned(WIDTH_CLK_CNT-1 downto 0) := (others => '0');
    signal sys_clk_cnt_max : std_logic := '0';
    signal spi_clk         : std_logic := '0';
    signal spi_clk_rst     : std_logic := '0';
    signal din_last_reg_n  : std_logic := '0';
    signal first_edge_en   : std_logic := '0';
    signal second_edge_en  : std_logic := '0';
    signal chip_select_n   : std_logic := '1';
    signal load_data       : std_logic := '0';
    signal miso_reg        : std_logic := '0';
    signal shreg           : std_logic_vector(WORD_SIZE-1 downto 0) := (others => '0');
    signal bit_cnt         : unsigned(BIT_CNT_WIDTH-1 downto 0) := (others => '0');
    signal bit_cnt_max     : std_logic := '0';
    signal rx_data_vld     : std_logic := '0';
    signal master_ready    : std_logic := '1';
    signal present_state   : state_t := idle;
    signal next_state      : state_t := idle;

begin

    -- Chequeo estático para SCLK_FREQ <= CLK_FREQ/10
    ASSERT DIVIDER_VALUE >= 5 REPORT "SCLK_FREQ must be <= CLK_FREQ/10" SEVERITY ERROR;

    load_data <= master_ready and DIN_VLD;
    DIN_RDY <= master_ready;

    -- Contador de reloj sistema para dividir frecuencia SPI
    sys_clk_cnt_max <= '1' when to_integer(sys_clk_cnt) = DIVIDER_VALUE - 1 else '0';

    sys_clk_cnt_reg_p : process(CLK) is
    begin
        if rising_edge(CLK) then
            if RST = '1' or sys_clk_cnt_max = '1' then
                sys_clk_cnt <= (others => '0');
            else
                sys_clk_cnt <= sys_clk_cnt + 1;
            end if;
        end if;
    end process;

    -- Generador reloj SPI
    spi_clk_gen_p : process(CLK) is
    begin
        if rising_edge(CLK) then
            if RST = '1' or spi_clk_rst = '1' then
                spi_clk <= '0';
            elsif sys_clk_cnt_max = '1' then
                spi_clk <= not spi_clk;
            end if;
        end if;
    end process;

    SCLK <= spi_clk;

    -- Contador de bits SPI
    bit_cnt_max <= '1' when bit_cnt = to_unsigned(WORD_SIZE-1, BIT_CNT_WIDTH) else '0';

    bit_cnt_p : process(CLK) is
    begin
        if rising_edge(CLK) then
            if RST = '1' or spi_clk_rst = '1' then
                bit_cnt <= (others => '0');
            elsif second_edge_en = '1' then
                bit_cnt <= bit_cnt + 1;
            end if;
        end if;
    end process;

    -- Registro dirección esclavo
    addr_reg_p : process(CLK) is
    begin
        if rising_edge(CLK) then
            if RST = '1' then
                addr_reg <= (others => '0');
            elsif load_data = '1' then
                addr_reg <= unsigned(DIN_ADDR);
            end if;
        end if;
    end process;

    -- Selección de chip (solo 1 esclavo)
    CS_N(0) <= chip_select_n;

    -- Registro DIN_LAST negado
    din_last_reg_n_p : process(CLK) is
    begin
        if rising_edge(CLK) then
            if RST = '1' then
                din_last_reg_n <= '0';
            elsif load_data = '1' then
                din_last_reg_n <= not DIN_LAST;
            end if;
        end if;
    end process;

    -- Registro muestreo MISO
    miso_reg_p : process(CLK) is
    begin
        if rising_edge(CLK) then
            if first_edge_en = '1' then
                miso_reg <= MISO;
            end if;
        end if;
    end process;

    -- Registro de desplazamiento de datos
    shreg_p : process(CLK) is
    begin
        if rising_edge(CLK) then
            if load_data = '1' then
                shreg <= DIN;
            elsif second_edge_en = '1' then
                shreg <= shreg(WORD_SIZE-2 downto 0) & miso_reg;
            end if;
        end if;
    end process;

    DOUT <= shreg;
    MOSI <= shreg(WORD_SIZE-1);

    -- Registro valid data out
    dout_vld_reg_p : process(CLK) is
    begin
        if rising_edge(CLK) then
            if RST = '1' then
                DOUT_VLD <= '0';
            else
                DOUT_VLD <= rx_data_vld;
            end if;
        end if;
    end process;

    -- FSM estado presente
    fsm_present_state_p : process(CLK) is
    begin
        if rising_edge(CLK) then
            if RST = '1' then
                present_state <= idle;
            else
                present_state <= next_state;
            end if;
        end if;
    end process;

    -- FSM siguiente estado
    fsm_next_state_p : process(present_state, DIN_VLD, sys_clk_cnt_max, bit_cnt_max) is
    begin
        case present_state is
            when idle =>
                if DIN_VLD = '1' then
                    next_state <= first_edge;
                else
                    next_state <= idle;
                end if;
            when first_edge =>
                if sys_clk_cnt_max = '1' then
                    next_state <= second_edge;
                else
                    next_state <= first_edge;
                end if;
            when second_edge =>
                if sys_clk_cnt_max = '1' then
                    if bit_cnt_max = '1' then
                        next_state <= transmit_end;
                    else
                        next_state <= first_edge;
                    end if;
                else
                    next_state <= second_edge;
                end if;
            when transmit_end =>
                if sys_clk_cnt_max = '1' then
                    next_state <= transmit_gap;
                else
                    next_state <= transmit_end;
                end if;
            when transmit_gap =>
                if sys_clk_cnt_max = '1' then
                    next_state <= idle;
                else
                    next_state <= transmit_gap;
                end if;
            when others =>
                next_state <= idle;
        end case;
    end process;

    -- FSM salida lógica
    fsm_outputs_p : process(present_state, din_last_reg_n, sys_clk_cnt_max) is
    begin
        case present_state is
            when idle =>
                master_ready   <= '1';
                chip_select_n  <= not din_last_reg_n;
                spi_clk_rst    <= '1';
                first_edge_en  <= '0';
                second_edge_en <= '0';
                rx_data_vld    <= '0';
            when first_edge =>
                master_ready   <= '0';
                chip_select_n  <= '0';
                spi_clk_rst    <= '0';
                first_edge_en  <= sys_clk_cnt_max;
                second_edge_en <= '0';
                rx_data_vld    <= '0';
            when second_edge =>
                master_ready   <= '0';
                chip_select_n  <= '0';
                spi_clk_rst    <= '0';
                first_edge_en  <= '0';
                second_edge_en <= sys_clk_cnt_max;
                rx_data_vld    <= '0';
            when transmit_end =>
                master_ready   <= '0';
                chip_select_n  <= '0';
                spi_clk_rst    <= '1';
                first_edge_en  <= '0';
                second_edge_en <= '0';
                rx_data_vld    <= sys_clk_cnt_max;
            when transmit_gap =>
                master_ready   <= '0';
                chip_select_n  <= not din_last_reg_n;
                spi_clk_rst    <= '1';
                first_edge_en  <= '0';
                second_edge_en <= '0';
                rx_data_vld    <= '0';
            when others =>
                master_ready   <= '0';
                chip_select_n  <= not din_last_reg_n;
                spi_clk_rst    <= '1';
                first_edge_en  <= '0';
                second_edge_en <= '0';
                rx_data_vld    <= '0';
        end case;
    end process;

end RTL;
